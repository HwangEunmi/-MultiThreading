**프로젝트 소개**
-------

멀티쓰레드 개념 공부를 진행하며 정리한 내용입니다.

프로젝트는 지속적으로 추가 될 예정입니다. 상단의 Star, Watching 버튼을 클릭하시면 구독 알림을 받으실 수 있습니다 :)


----------


**목차**
--

 - [프로젝트 소개](#프로젝트-소개)
 - [목차](#목차)
 - [전체 플로우](#전체-플로우)
  - [쓰레드의 동기화](#쓰레드의-동기화)
   - [synchronized를 이용한 동기화](#synchronized를-이용한-동기화)
   - [wait()메소드와 notify()메소드](#wait()메소드와-notify()메소드)
   - [notify()메소드 vs notifyAll()메소드](#notify()메소드-vs-notifyAll()메소드)
   
  
   - [쓰레드를 사용하는 경우?](#쓰레드를-사용하는-경우?)
   - [쓰레드의 개수 제한](#쓰레드의-개수-제한)
   
   
----------

**전체 플로우**
----------

**쓰레드의 동기화**
------

싱글 쓰레드 프로세스의 경우, 프로세스 내에서 단 하나의 쓰레드만 작업하기 때문에 

프로세스의 자원을 가지고 작업하는데 별 문제가 없지만,

멀티쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업하기 때문에

서로의 작업에 영향을 주게 된다.

이런 일이 발생하는 것을 방지하기 위해서 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해

방해받지 않도록 해야 하는데,

그래서 도입된 개념이 바로 '임계 영역'과 '잠금(lock)' 이다.

임계 영역이란 공유 데이터를 사용하는 코드 영역을 말하고,

공유 데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만이 이 영역 내의 코드를 수행할 수 있도록 한다.

그리고 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야

비로소 다른 쓰레드가 반납된 lock을 획득하여 임계 영역의 코드를 수행할 수 있게 한다.


=> 이처럼 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하게 하는 것을 쓰레드의 동기화라고 한다.


----------

**synchronized를 이용한 동기화**
------

이 키워드는 임계 영역을 설정하는데 사용된다. 두가지 방식이 있다.

```java
// 1. 메서드 전체를 임계 영역으로 지정한다.
  public synchronized void test() {
     // ...
  }
  
// 2. 특정한 영역을 임계 영역으로 지정한다.
  public void test() {
     // ...
     synchronized(객체의 참조변수) {
       // ...
     }
  }
```

1번 방법은 쓰레드는 synchronized메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 lock을 얻어 

작업을 수행하다가 메서드가 종료되면 lock을 반환한다.

2번 방법은 코드 일부를 블럭{}으로 감싸고 synchronized(참조변수)를 붙이는 것인데, 

이때 참조변수는 락을 걸고자하는 객체를 참조하는 것이어야 한다. 

이 블럭의 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 lock을 얻게 되고, 이 블럭을 벗어나면 lock을 반납한다.

두 방법 모두 lock의 획득/반납이 모두 자동적으로 이루어지므로 그저 임계 영역만 설정해주면 된다.

모든 객체는 lock을 하나씩 가지고 있으며, 해당 객체의 lock을 가지고 있는 쓰레드만 임계 영역의 코드를 수행할 수 있다.

그리고 다른 쓰레드들은 lock을 얻을 때까지 기다려야 한다.


임계 영역은 멀티 쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 2번 방법으로 임계 영역을 최소화해야 한다.

```java
public static void main(String[] args) {
  // 쓰레드를 2개 생성한다.
  Runnable r = new Thread01();
  new Thread(r).start();
  new Thread(r).start();
}

class Thread01 implements Runnable {
  private int money = 1000;
  public void run() {
     if(money > 0) {
       money -= 200;
     }
     System.out.println(money);
  }
}

/**
* 실행결과
* 800
* 600
* ...
* 0
* -200
*/
```
실행결과에서 money가 음수인 것을 볼 수 있다.

그 이유는 한 쓰레드가 if문의 조건식을 통과하고 -연산을 하기 바로 직전에, 

쓰레드에게 제어권이 넘어가서 다른 쓰레드가 -연산을 한 후 출력을 했기 때문이다.

이 상태에서 이전 쓰레드로 제어권이 넘어오면 if문 다음부터 수행되므로 0인 상태에서 -200을 하게 된 것이다.

그래서 if문과 연산하는 문장은 하나의 임계 영역으로 묶여야 한다.

```java
  public void run() {
    synchronized(this) {
      if(money > 0) {
        money -= 200;
      }
    }
 }
```

이런 식으로 동기화를 시키면 한 쓰레드에 의해서 이 메소드가 호출되었을 때,

이 메소드가 종료되어 lock이 반납될 때까지 다른 쓰레드는 이 메소드를 호출하더라도 대기상태에 머물게 된다.


----------

**wait()메소드와 notify()메소드**
------
synchronized로 동기화해서 공유 데이터를 보호할 수 있지만 

특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지않도록 하는 것도 중요하다.

이러한 상황을 개선하기 위해 wait()와 notify()메소드를 사용할 수 있다.

동기화된 임계 영역의 코드를 수행하다가 작업을 더이상 진행할 상황이 아니면, 

일단 wait()메소드를 호출하여 쓰레드가 lock을 반납하고 기다리게 한다.

그러면 다른 쓰레드가 lock을 얻어 해당 객체에 대한 작업을 수행할 수 있게 한다.

나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출해서, 작업을 중단했던 쓰레드가

다시 lock을 얻어 작업을 진행할 수 있게 한다.


wait()메소드를 호출하면 실행중이던 쓰레드는 해당 객체의 대기실(Waiting Pool)에서 통지를 기다린다.

notify()메소드가 호출되면, 해당 객체의 대기실에 있던 모든 쓰레드 중에서 임의의 쓰레드만 통지를 받는다.

notifyAll()메소드는 기다리고 있는 모든 쓰레드에게 통보를 하지만, 그래도 lock을 얻을 수 있는것은 하나의 쓰레드이고

나머지 쓰레드는 통보를 받긴 했지만 lock을 얻지 못하면 다시 lock을 기다려야 한다.

참고로 Waiting Pool은 객체마다 존재한다. 

// TODO : 예제 추가 필요 (p.772~)

----------

**notify()메소드 vs notifyAll()메소드**
------
notify()메소드는 WAIT_SET에서 대기중인 임의의 한개의 쓰레드를 다시 Runnable 상태로 변경한다. 

반면에 notifyAll()메소드는 WAIT_SET에 있는 모든 쓰레드를 Runnable 상태로 변경한다.

어차피 모두 깨워도 동시에 작동하는 것이 아닌, lock을 갖기 위해 다시 경쟁해야 한다. 

즉, 두 메소드 모두 콕 찝어서 호출하는 것이 아닌, 임의의 쓰레드를 호출하는 것이다.

그래서 Lock과 Condition을 이용하여 선별적으로 통지를 할 수 있다. 

참고로 wait(), notify(), notifyAll()메소드는 synchronized 블록 내에서 실행되어야 한다.

(호출 쓰레드가 반드시 대상 객체의 고유 lock을 갖고 있어야 한다는 것이다.)

만일 고유 락을 획득하지 않은 상태에서 세가지 메소드 중 하나를 호출하면 IllegalMonitorStateException이 발생한다.



----------

**notify()메소드 vs notifyAll()메소드**
------













































