**프로젝트 소개**
-------

멀티쓰레드 개념 공부를 진행하며 정리한 내용입니다.

프로젝트는 지속적으로 추가 될 예정입니다. 상단의 Star, Watching 버튼을 클릭하시면 구독 알림을 받으실 수 있습니다 :)


----------


**목차**
--

 - [프로젝트 소개](#프로젝트-소개)
 - [목차](#목차)
 - [전체 플로우](#전체-플로우)
  
  - [쓰레드의 우선순위](#쓰레드의-우선순위)
  - [데몬 쓰레드](#데몬-쓰레드)
  - [쓰레드의 상태와 Life Cycle](#쓰레드의-상태와-Life-Cycle)
   - [sleep() 메소드](#sleep()-메소드)
   - [interrupt() 메소드](#interrupt()-메소드)
   - [suspend()/resume()/stop() 메소드](#suspend()-resume()-stop()-메소드)
   - [교착상태](#교착상태)
   - [yield() 메소드](#yield()-메소드)
   - [join() 메소드](#join()-메소드)
   
----------

**전체 플로우**
----------

**쓰레드의 우선순위**
------

쓰레드에도 우선순위를 지정할 수 있다. 

```java
void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다. 
```

쓰레드가 가질 수 있는 우선순위 범위는 1~10 이며 숫자가 높을수록 우선순위가 높다.

쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는데, 참고로 main쓰레드의 우선순위는 5이다.

사실 우선순위를 높게한다고 해도 더 많은 실행시간과 실행기회를 갖게될 것이라고 기대하는 것이지 그렇게 되는 것은 보장할 수 없다. 

(OS마다 다른 방식으로 스케쥴링하기 때문에, OS별로 결과가 다르다.)

그러므로 차라리 쓰레드에 우선순위를 부여하는 대신, 작업에 우선순위를 두어 PriorityQueue에 저장해놓고,

우선순위가 높은 작업이 먼저 처리되도록 하는 것이 낫다. 


----------
**데몬 쓰레드**
------

데몬 쓰레드는 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.

일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료된다. 

(보조역할이므로 일반 쓰레드가 모두 종료되고 나면 존재 의미가 없기 때문에)

이 점을 제외하고는 일반 쓰레드와 다르지 않다.

데몬 쓰레드의 예로는 GC 등이 있다. 

데몬 쓰레드는 무한루프와 조건문을 이용해서 실행후 대기하고 있다가, 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다. 

생성방법은 쓰레드를 생성하고 실행하기 전에 setDaemon(true)를 호출해주기만 하면 된다.

```java
private boolean isAutoSave = false;
public static void main(String[] args) {
  Thread t = new Thread(new Thread01);
  t.setDaemon(true);
  t.start();  
  
  for(int i = 0; i <10; i++) {
      try {
         Thread.sleep(1000);
      } catch (InterruptedException e) {}
      System.out.println(i);
      
      if(i==5) {
        isAutoSave = true;
      }
      
      System.out.println("프로그램을 종료합니다.");
}

// 3초마다 변수 isAutoSave의 값을 확인해서 println을 무한히 진행한다.
public class Thread01 implements Runnable {
   public void run() {
      while(true) {
         try {
           Thread.sleep(3*1000); // 3초
         } catch (InterruptException e) {}
       
        // 3초마다 isAutoSave의 값을 확인한다.
        if(isAutoSave) {
           System.out.println("작업파일이 자동저장되었습니다.");
        }
     }
  }
}
 /**
 *실행결과
 * 1
 * 2
 * 3
 * 4
 * 5
 * 6
 * 작업파일이 자동저장되었습니다.
 * 7
 * 8
 * 작업파일이 자동저장되었습니다.
 * 9
 * 10
 * 프로그램을 종료합니다.
 */
```

만일 데몬 쓰레드로 작성하지 않았다면 이 프로그램은 강제종료하지 않는 한 영원히 종료되지 않았을 것이다.

프로그램을 실행하면, JVM은 GC, 그래픽처리 등 실행되는데 필요한 보조작업을 수행하는 데몬 쓰레드들을 자동적으로 생성하여 실행시킨다.


----------
**쓰레드의 상태와 Life Cycle**
------

쓰레드 프로그래밍이 어려운 이유는 동기화와 스케줄링 때문이다.

효율적인 멀티쓰레드 프로그램을 만들기 위해서는 보다 정교환 스케줄링을 통해 프로세스에게

주어진 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용하도록 프로그래밍을 해야 한다.

쓰레드 스케줄링을 잘하기 위해서는 쓰레드 상태를 잘 알아야 한다.

다음은 쓰레드의 스케쥴링 관련된 메소드이다.

    ● static void sleep(long millis) : 지정된 시간동안 쓰레드를 일시정지 시킨다. 
      
                                       지정한 시간이 지나고나면, 자동적으로 다시 실행대기 상태가 된다.

    ● void join(long millis) : 쓰레드 자신이 하던 작업을 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 한다.

                               만일 시간을 지정하지 않으면, 해당 쓰레드가 작업을 모두 마칠 때까지 기다리게 된다.
                           
                               다시 말해서, 작업 중 다른 쓰레드의 작업이 먼저 수행되어야 할 경우 사용한다.
                           
    ● void interrupt() : sleep()이나 join()에 의해 일시정지 상태인 쓰레드를 깨워서 실행대기 상태로 만든다. 

                         해당 쓰레드에서는 InterruptedException이 발생하면서 일시정지상태에서 벗어난다.
                     
    ● stop() : 쓰레드를 즉시 종료시킨다. (deprecated 된 메소드)

    ● suspend() : 쓰레드를 일시정지시킨다. (deprecated 된 메소드)

    ● resume() : 일시정지 상태에 있는 쓰레드를 실행대기상태로 만든다. (deprecated 된 메소드)

    ● yield() : 쓰레드 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보한다. 

                양보한 후 해당 쓰레드는 다시 실행대기 상태가 된다. 
            
            
----------          

다음은 쓰레드의 상태에 대해서 살펴보자.

* NEW : 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태

* RUNNABLE : 실행 중 또는 실행가능한 상태

* BLOCKED : 동기화블럭에 의해서 일시정지 된 상태 (lock이 풀릴 때까지 기다리는 상태)

* WAITING,
  TIMED_WAITING : 쓰레드의 작업이 종료되지는 않았지만 일시정지 된 상태, TIMED는 일시정지시간이 지정된 경우
  
* TERMINATED : 쓰레드의 작업이 종료된 상태


![Thread_Cycle](/image/Thread_Cycle.png)

(1) 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아닌, 실행대기열에 저장되어 자신의 차례가 될 때까지 

 기다린다. 실행대기열은 큐(Queue)와 같은 구조로 먼저 실행대기열에 들어온 쓰레드가 먼저 실행된다.
 
(2) 실행대기 상태에 있다가 자신의 차례가 되면 실행상태가 된다.

(3) 주어진 실행시간이 다 되거나 yield()를 만나면 다시 실행대기 상태가 되고, 다음 차례의 쓰레드가 실행상태가 된다.

(4) 실행중에 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지 상태가 될 수 있다.

 I/O block은 입출력작업에서 발생하는 지연상태를 말한다. 사용자의 입력을 기다리는 경우를 예로 들 수 있는데,
 
 이런 경우 일시정지 상태에 있다가 사용자가 입력을 마치면 다시 실행대기 상태가 된다.
 
(5) 지정된 일시정지시간이 다 되거나(time-out), notify(), resume(), interrupt()가 호출되면 일시정지상태를 벗어나

 다시 실행대기열에 저장되어 자신의 차례를 기다리게 된다.

(6) 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸된다.


=> 번호를 나열해놨지만 사실 번호의 순서대로 쓰레드가 수행되는 것은 아니다.


이제 메소드를 하나씩 자세히 살펴보자.
                                   
----------
**sleep() 메소드**
------

sleep(long millis)메소드는 지정된 시간동안 쓰레드를 멈추게 한다.

sleep()에 의해 일시정지 상태가 된 쓰레드는 지정된 시간이 다 되거나, interrupt()가 호출되면 InterruptedException이 발생되어

잠에서 깨어나 실행대기 상태가 된다. 

그래서 sleep()을 호출할 때는 항상 try/catch문으로 예외 처리를 해줘야 한다.


```java
try {
  Thread.sleep(3000); // 쓰레드를 3초동안 멈추게 한다.
} catch(InterruptedException e) {
  // 3초가 지난 후 Exception이 여기서 발생한다.
     3초가 지난 후의 로직을 이곳에 넣는다.
}
```

sleep()메소드는 항상 현재 실행중인 쓰레드에 대해 작동하기 때문에 th01.sleep(2000)라고 호출해도 

실제로 영향을 받는 것은 현재 실행중인 쓰레드이다. 

만약 작동하고 있는 쓰레드가 여러개인 경우 랜덤으로 sleep()메소드를 만나게 되어 일시정지한다.

그러므로 sleep()메소드는 참조변수를 이용해서 호출하기 보다는 Thread.sleep(2000); 로 사용해야 한다.


----------
**interrupt() 메소드**
------

interrupt()메소드는 쓰레드의 작업을 취소한다.

진행중인 쓰레드의 작업이 끝나기 전에 취소시켜야 할 때가 있다. 

예를 들어 큰 파일을 다운로드할때 시간이 너무 오래 걸리면 중간에 다운로드를 취소할 수 있어야 한다.

이때 interrupt()메소드는 쓰레드에게 작업을 멈추라고 요청한다.  

사실 멈추라고 요청만 하는 것이지 쓰레드를 강제로 종료시키지는 못한다. 

내부에서 그저 interrupted 상태 인스턴스 변수를 바꾸는 것일 뿐이다. (false에서 true로 바뀌어 while문을 벗어남)

관련 메소드는 다음과 같다.

* void interrupt() : 쓰레드의 interrupted상태를 false에서 true로 변경

* boolean isInterrupted() : 쓰레드의 interrupted상태를 반환

* static boolean interrupted() : 현재 쓰레드의 interrupted상태를 알려주고, false로 초기화

interrupt()메소드는 또 다른 역할을 할 수 있다.

쓰레드가 sleep(), wait(), join()에 의해 일시정지 상태일 경우(WAITING),

해당 쓰레드에 대해 interrupt()메소드를 호출하면 sleep(), wait(), join()에서 InterruptedException이 발생하고

쓰레드는 실행대기 상태(RUNNABLE)로 바뀐다.

즉, 멈춰있던 쓰레드를 깨워서 실행가능한 상태로 만들 수 있다.


```java
try {
  Thread.sleep(3000); // 쓰레드를 3초동안 멈추게 한다.
} catch(InterruptedException e) {
  // 3초가 지난 후 Exception이 여기서 발생한다.
     이와 마찬가지로, 쓰레드가 멈춰 있는 상태에서 interrupt()메소드를 호출해도
     이곳에서 Exception이 발생하여 쓰레드가 실행대기 상태로 된다. (false로 초기화)     
}
```

----------
**suspend(), resume(), stop() 메소드**
------

suspend()메소드는 쓰레드를 일시정지 상태로, resume()메소드는 다시 재개, stop()메소드는 쓰레드를 종료시킨다. 

이 세가지 메소드는 쓰레드를 내부적으로 교착상태(DeadLock)로 만들기 쉬워 deprecated 되었고 현재 사용을 권고하지 않는다.

----------
**교착상태**
------
예시를 살펴보자.

선생님이 방과후에 철수와 영희에게 교실청소를 부탁했다.

철수는 빗자루를 가지고 있고, 영희는 쓰레받기를 들고 있다.

철수 입장에선 쓰레받기가 있어야 빗자루질을 할 수 있으니 영희가 쓰레받기를 다 쓰길 무한정 기다린다.

영희 입장에선 철수가 빗자루로 빗자루질을 다 해야 빗자루를 받을 수 있으니 철수가 빗자루를 다 쓰길 무한정 기다린다. (쓰레받기를 꼭 쥔 채)

이제 둘은 영원히 집에 갈 수 없다.


=> 교착상태는 동일한 자원을 공유하고 있는 두 개의 컴퓨터 프로그램들이

상대방이 자원에 접근하는 것을 사실 상 서로 방해함으로써, 두 프로그램 모두 기능이 중지되는 결과를 낳는 상황을 말한다.

프로그램 1이 자원 A를 요청하여 그것을 할당받았다.

프로그램 2가 자원 B를 요청하여 그것을 할당받았다.

프로그램 1이 자원 B를 추가로 요청했으나, 자원 B가 다른 프로그램에 의해 사용중이므로(프로그램 2)

사용 가능한 상태가 될 때까지 대기열에서 기다리고 있다.

프로그램 2가 자원 A를 추가로 요청했으나, 자원 A가 다른 프로그램에 의해 사용중이므로(프로그램 1)

사용 가능한 상태가 될 때까지 대기열에서 기다리고 있다.

이제 두 프로그램은 서로 상대방이 자원을 내놓을 때까지 자원을 멈추고 기다리게 된다.


----------
**yield() 메소드**
------

yield()메소드는 쓰레드 자신에게 주어진 실행시간을 다음 차례의 쓰레드에게 양보하도록 한다.

예를 들어 스케쥴러에 의해 1초의 실행시간을 할당받은 쓰레드가 0.5초의 시간동안 작업한 상태에서

yield()메소드가 호출되면, 나머지 0.5초는 포기하고 다시 실행대기상태가 된다.

yield()메소드와 interrupt()메소드를 적절히 사용하면, 프로그램의 응답성을 높이고

보다 효율적인 실행이 가능하게 할 수 있다.

(interrupt()메소드는 호출 즉시 InterruptedException이 발생하여 즉시 일시정지 상태에서 벗어나게 되므로

yield()메소드 또한 호출 즉시 다음 차례의 쓰레드를 실행시키므로)

```java
try {
  Thread.sleep(3000); // 쓰레드를 3초동안 멈추게 한다.
} catch(InterruptedException e) {
  Thread.yield(); // 즉시 다른 쓰레드에게 순서를 넘긴다.
}
```

----------
**join() 메소드**
------

join(long millis)메소드는 쓰레드 자신이 하던 작업을 잠시 멈추고 다른 쓰레드가 지정된 시간동안 작업을 수행하도록 한다.

시간을 지정하지 않으면, 해당 쓰레드가 작업을 모두 마칠 때까지 기다리게 된다. 

즉, 작업 중에 다른 쓰레드의 작업이 먼저 수행되어야 할 필요가 있을 때 join()메소드를 사용한다. 

join()메소드도 sleep()메소드처럼 interrupt()메소드에 의해 대기상태에서 벗어날 수 있으므로

try/catch문으로 감싸야 한다. 

sleep()메소드와 유사한 점이 많은데, 다른 점은 join()메소드는 현재 쓰레드가 아닌 특정 쓰레드에 대해서 동작한다는 것이다.


```java
private long startTime = 0;
public static void main(String[] args) {
  Thread t = new Thread(new Thread01());
  t.start();
  
  try {
    t.join(); // 현재 실행중인 쓰레드가(여기선 main쓰레드) 쓰레드 Thread01의 작업이 끝날때까지 기다린다.
  } catch(InterruptedException e) {
    // 시간이 모두 지났거나, interrupt()메소드가 호출될 경우 이 곳이 호출된다.
    // ...
  }
  System.out.println("소요시간 : " + System.currentTimeMills() - startTime);
 }
 
 class Thread01 implements Runnable {
   public void run() {
     for(int i = 0; i < 5; i++) {
       System.out.println(i);
     }
   }
 }
 
 /**
 * 실행결과
 * 1
 * 2
 * 3
 * 4
 * 5
 * 소요시간 : 11
 */
```
만약 join()메소드를 사용하지 않았다면 main쓰레드는 바로 종료되어 정확한 소요시간을 구할 수 없었을 것이다.

즉, Thread01의 작업이 충분히 진행되길 기다려주는 것이다.

어떤 순간에 어떤 스레드의 작업이 확실하게 진행할 것을 보장해야 하는 경우, join()메소드를 사용한다. 





